{% extends "base.html" %}

{% block head_extra %}
<style>
    body.index-page-background {
        background: linear-gradient(to bottom right, #C33764 , #1D2671);
        position: relative;
        z-index: 0;
    }

    body.index-page-background::before {
        content: '';
        position: fixed; 
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: inherit; 
        filter: blur(8px) brightness(0.95);
        -webkit-filter: blur(8px) brightness(0.55);
        z-index: -1; 
    }

    #videoElement {
        display: block;
        width: 100%;
        height: auto;
        transform: scaleX(-1); 
        border-radius: calc(var(--border-radius-main) - 10px); 
    }
    #overlayCanvas {
        position: absolute;
        top: 10px; 
        left: 10px; 
        width: calc(100% - 20px); 
        height: calc(100% - 20px); 
        transform: scaleX(-1); 
        pointer-events: none; 
    }
    .controls-card {
        margin-top: 1.5rem;
    }
    .page-title-card {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        text-align: center;
        padding-bottom: 0;
    }
    .page-title-card h2 {
        color: var(--secondary-white);
        font-weight: 600;
        text-shadow: 1px 1px 4px rgba(0,0,0,0.4);
    }
    .page-title-card p {
        color: var(--text-color-light);
        opacity: 0.95;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    .page-title-card #istTimeDisplay {
        color: var(--text-color-light);
        font-size: 0.95rem;
        font-weight: 500;
        opacity: 0.9;
        margin-top: 5px;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.25);
    }

    #popupAlertContainer {
        position: absolute; 
        top: 150px;
        left: 15px;
        z-index: 2050;
        width: auto;
        max-width: 90%;
        display: flex;
        flex-direction: column;
        align-items: flex-end; 
        padding-top: 10px; 
    }

    .popup-alert {
        min-width: 250px; 
        max-width: 350px; 
        text-align: left; 
        margin-bottom: 10px;
        animation: fadeInSlideDown 0.5s ease-out forwards;
        opacity: 0;
        transform: translateY(-20px);
    }
    .popup-alert.fade-out {
        animation: fadeOutSlideUp 0.5s ease-in forwards;
    }

    .popup-alert {
        box-shadow: 0 0 20px 6px rgba(220, 235, 255, 0.6), 
                    0 5px 10px rgba(0,0,0,0.2); 
    }

    .popup-alert.alert-success {
        border-color: rgba(238, 245, 41, 0.767); 
        box-shadow: 0 0 20px 6px rgba(200, 191, 70, 0.7), 
                    0 5px 10px rgba(0,0,0,0.2);
    }
    .popup-alert.alert-danger {
        border-color: rgba(220, 53, 69, 0.6);
        box-shadow: 0 0 20px 6px rgba(255, 80, 100, 0.7), 
                    0 5px 10px rgba(0,0,0,0.2);
    }
    .popup-alert.alert-info {
        border-color: rgb(255, 218, 97);
        box-shadow: 0 0 20px 6px rgba(208, 210, 60, 0.7), 
                    0 5px 10px rgba(0,0,0,0.2);
    }
    .popup-alert.alert-warning {
        border-color: rgba(255, 193, 7, 0.6);
        box-shadow: 0 0 20px 6px rgba(255, 200, 50, 0.7), 
                    0 5px 10px rgba(0,0,0,0.2);
    }
    .popup-alert.alert-secondary { 
        border-color: rgba(108, 117, 125, 0.6);
        box-shadow: 0 0 20px 6px rgba(130, 140, 150, 0.5), 
                    0 5px 10px rgba(0,0,0,0.2);
    }

    @keyframes fadeInSlideDown {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes fadeOutSlideUp {
        from {
            opacity: 1;
            transform: translateY(0);
        }
        to {
            opacity: 0;
            transform: translateY(-20px);
        }
    }

    /* Auto Mode Toggle Styles */
    .auto-mode-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        backdrop-filter: blur(10px);
    }

    .auto-mode-label {
        color: var(--secondary-white);
        font-weight: 500;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    /* Custom Toggle Switch */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 34px;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .slider {
        background-color: #28a745;
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    /* Auto mode indicator */
    .auto-mode-indicator {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 8px 15px;
        background: rgba(40, 167, 69, 0.2);
        border: 2px solid #28a745;
        border-radius: 20px;
        color: #28a745;
        font-weight: 600;
        animation: pulse 2s infinite;
    }

    .auto-mode-indicator.active {
        display: flex;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .recognition-status {
        text-align: center;
        margin-top: 10px;
        font-size: 0.9rem;
        color: var(--text-color-light);
        min-height: 20px;
    }

</style>
{% endblock %}

{% block body_attributes %}class="index-page-background"{% endblock %}

{% block content %}
<div id="popupAlertContainer"></div>

<div class="container mt-1 pt-1"> 
    <div class="row justify-content-center">
        <div class="col-lg-7 col-md-9">

            <div class="card page-title-card mb-4">
                <div class="card-body pb-0">
                    <h2>Mark Your Attendance</h2>
                    <p>Please look directly into the camera.</p>
                    <p id="istTimeDisplay" class="mb-0">Loading IST time...</p> 
                </div>
            </div>

            <div id="videoFeedContainer" class="mb-3" style="position: relative;">
                <video id="videoElement" autoplay playsinline muted></video>
                <canvas id="overlayCanvas"></canvas>
            </div>

            <div class="card controls-card">
                <div class="card-body">
                    <!-- Auto Mode Toggle -->
                    <div class="auto-mode-container">
                        <span class="auto-mode-label">Manual Mode</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoModeToggle">
                            <span class="slider"></span>
                        </label>
                        <span class="auto-mode-label">Auto Mode</span>
                    </div>

                    <!-- Auto Mode Indicator -->
                    <div class="auto-mode-indicator" id="autoModeIndicator">
                        <span>ðŸ”„</span>
                        <span>Auto Recognition Active</span>
                    </div>

                    <!-- Recognition Status -->
                    <div class="recognition-status" id="recognitionStatus"></div>

                    <!-- Manual Controls -->
                    <div class="text-center" id="manualControls">
                        <button id="markAttendanceBtn" class="btn btn-primary btn-lg me-2" disabled>Mark My Attendance</button>
                        <button id="stopCameraBtn" class="btn btn-secondary btn-lg" style="display: none;">Stop Camera</button>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>

<canvas id="snapshotCanvas" style="display:none;"></canvas>

{% endblock %}

{% block scripts_extra %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    const video = document.getElementById('videoElement');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const overlayCtx = overlayCanvas.getContext('2d');
    const snapshotCanvas = document.getElementById('snapshotCanvas');
    const markAttendanceBtn = document.getElementById('markAttendanceBtn');
    const stopCameraBtn = document.getElementById('stopCameraBtn');
    const popupAlertContainer = document.getElementById('popupAlertContainer');
    const istTimeDisplay = document.getElementById('istTimeDisplay');
    const autoModeToggle = document.getElementById('autoModeToggle');
    const autoModeIndicator = document.getElementById('autoModeIndicator');
    const recognitionStatus = document.getElementById('recognitionStatus');
    const manualControls = document.getElementById('manualControls');
    
    let stream;
    let preferredDeviceId = null; 
    let clockIntervalId = null;
    let autoModeEnabled = false;
    let autoRecognitionInterval = null;
    let lastRecognizedEmployee = null;
    let recognitionStartTime = null;
    let isProcessingAttendance = false;
    
    const RECOGNITION_THRESHOLD_MS = 5000; // 5 seconds
    const AUTO_CHECK_INTERVAL_MS = 500; // Check every 500ms

    function updateISTClock() {
        const now = new Date();
        const options = {
            timeZone: 'Asia/Kolkata',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: true
        };
        const timeString = now.toLocaleTimeString('en-IN', options);
        if (istTimeDisplay) {
            istTimeDisplay.textContent = `Current Time: ${timeString}`;
        }
    }

    function updateStatus(message, type = 'info', duration = 3500) {
        const alertDiv = document.createElement('div');
        const alertType = ['success', 'danger', 'warning', 'info', 'secondary', 'primary', 'light', 'dark'].includes(type) ? type : 'info';
        alertDiv.className = `alert alert-${alertType} popup-alert`; 
        alertDiv.textContent = message;
        
        popupAlertContainer.appendChild(alertDiv);

        setTimeout(() => { 
            alertDiv.classList.add('fade-out');
            setTimeout(() => {
                if (alertDiv.parentNode === popupAlertContainer) { 
                    popupAlertContainer.removeChild(alertDiv);
                }
            }, 500);
        }, duration - 500);
    }

    function updateRecognitionStatus(message) {
        if (recognitionStatus) {
            recognitionStatus.textContent = message;
        }
    }

    async function findPreferredCamera() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            if (videoDevices.length === 0) {
                updateStatus('No video input devices found.', 'danger');
                return null;
            }
            
            const internalCameraKeywords = ['integrated webcam', 'built-in camera', 'laptop camera', 'internal camera', 'facing front', 'usb2.0 hd uvc webcam'];
            const externalCameraKeywords = ['logitech', 'droidcam', 'obs virtual camera', 'external', 'usb video device'];

            let externalCameras = videoDevices.filter(device => {
                const labelLower = device.label.toLowerCase();
                if (externalCameraKeywords.some(keyword => labelLower.includes(keyword))) {
                    return true;
                }
                return !internalCameraKeywords.some(keyword => labelLower.includes(keyword));
            });
            
            if (externalCameras.length === 0) {
                 externalCameras = videoDevices.filter(device => {
                    const labelLower = device.label.toLowerCase();
                    return !internalCameraKeywords.some(keyword => labelLower.includes(keyword));
                });
            }

            if (externalCameras.length > 0) {
                console.log('Preferred camera found:', externalCameras[0].label);
                preferredDeviceId = externalCameras[0].deviceId;
                return preferredDeviceId;
            } else if (videoDevices.length > 0) {
                console.log('Using first available camera:', videoDevices[0].label);
                preferredDeviceId = videoDevices[0].deviceId;
                return preferredDeviceId;
            }
            return null;
        } catch (err) {
            console.error("Error enumerating devices: ", err);
            updateStatus('Error accessing camera list. ' + err.message, 'danger');
            return null;
        }
    }

    async function startCamera() {
        markAttendanceBtn.disabled = true;
        stopCameraBtn.style.display = 'none';
        updateStatus('Initializing camera...', 'info', 2000); 

        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }

        if (!preferredDeviceId) {
            preferredDeviceId = await findPreferredCamera();
        }
        
        const constraints = {
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30, min: 15 } 
            },
            audio: false
        };

        if (preferredDeviceId) {
            constraints.video.deviceId = { exact: preferredDeviceId };
        }

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.onloadedmetadata = async () => {
                await video.play();

                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;
                snapshotCanvas.width = video.videoWidth;
                snapshotCanvas.height = video.videoHeight;

                markAttendanceBtn.disabled = false;
                stopCameraBtn.style.display = 'inline-block';
                
                const currentTrack = stream.getVideoTracks()[0];
                const settings = currentTrack.getSettings();
                let cameraLabel = "Unknown Camera";

                if (settings.deviceId) {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const actualDevice = devices.find(d => d.deviceId === settings.deviceId);
                    cameraLabel = actualDevice && actualDevice.label ? actualDevice.label : (settings.label || "Selected Camera");
                } else if (currentTrack.label) {
                    cameraLabel = currentTrack.label;
                }
                
                updateStatus(`Camera started (${cameraLabel}). Position your face.`, 'info');
                console.log("Using camera:", cameraLabel, "ID:", settings.deviceId || "N/A");
            };
            video.onplay = () => {
                 if (overlayCanvas.width !== video.videoWidth || overlayCanvas.height !== video.videoHeight) {
                    overlayCanvas.width = video.videoWidth;
                    overlayCanvas.height = video.videoHeight;
                    snapshotCanvas.width = video.videoWidth;
                    snapshotCanvas.height = video.videoHeight;
                    console.log("Canvas dimensions updated onplay:", video.videoWidth + "x" + video.videoHeight);
                }
            };

        } catch (err) {
            console.error("Error accessing camera: ", err);
            let message = 'Could not access camera. Check permissions. ' + err.name + ": " + err.message;
            
            if (preferredDeviceId && (err.name === "OverconstrainedError" || err.name === "NotFoundError" || err.name === "NotReadableError" || err.name === "SourceUnavailableError")) {
                updateStatus(`Failed with preferred camera. Trying system default...`, 'warning', 2500);
                console.warn(`Failed to access preferred camera. Trying default.`);
                delete constraints.video.deviceId;
                preferredDeviceId = null;
                try {
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream; 
                    video.onloadedmetadata = async () => {
                        await video.play();
                        overlayCanvas.width = video.videoWidth;
                        overlayCanvas.height = video.videoHeight;
                        snapshotCanvas.width = video.videoWidth;
                        snapshotCanvas.height = video.videoHeight;
                        markAttendanceBtn.disabled = false;
                        stopCameraBtn.style.display = 'inline-block';
                        updateStatus('Camera started with default device.', 'info');
                    };
                } catch (defaultErr) {
                    console.error("Error accessing default camera: ", defaultErr);
                    updateStatus('Could not access any camera. Check permissions. ' + defaultErr.name + ": " + defaultErr.message, 'danger');
                }
            } else {
                updateStatus(message, 'danger');
            }
        }
    }

    function stopCamera() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            video.srcObject = null;
            markAttendanceBtn.disabled = true;
            stopCameraBtn.style.display = 'none';
            if(overlayCtx) overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            updateStatus('Camera stopped.', 'secondary'); 
            stream = null;
        }
        stopAutoRecognition();
    }

    async function captureAndRecognize(isAutoMode = false) {
        // This function ONLY recognizes faces, does NOT mark attendance
        if (!stream || !video.srcObject || video.paused || video.ended || video.readyState < video.HAVE_CURRENT_DATA) {
            if (!isAutoMode) {
                updateStatus('Camera not active or ready. Please wait or restart camera.', 'warning');
            }
            return null;
        }

        const context = snapshotCanvas.getContext('2d');
        if (snapshotCanvas.width !== video.videoWidth || snapshotCanvas.height !== video.videoHeight) {
            snapshotCanvas.width = video.videoWidth;
            snapshotCanvas.height = video.videoHeight;
        }

        if (video.style.transform === 'scaleX(-1)') {
            context.translate(snapshotCanvas.width, 0);
            context.scale(-1, 1);
            context.drawImage(video, 0, 0, snapshotCanvas.width, snapshotCanvas.height);
            context.setTransform(1, 0, 0, 1, 0, 0);
        } else {
            context.drawImage(video, 0, 0, snapshotCanvas.width, snapshotCanvas.height);
        }
        const imageDataURL = snapshotCanvas.toDataURL('image/jpeg', 0.9);

        try {
            // Send with auto_mode false to just recognize, not mark attendance
            const response = await fetch("{{ url_for('mark_attendance_route') }}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    image_data: imageDataURL,
                    auto_mode: false,  // Just recognize, don't mark yet
                    recognize_only: true  // New flag to indicate we only want recognition
                }),
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server error: ${response.status} ${response.statusText}. ${errorText}`);
            }
            const result = await response.json();
            return result;

        } catch (error) {
            console.error('Error during recognition:', error);
            if (!isAutoMode) {
                updateStatus('An error occurred. Please try again. ' + error.message, 'danger');
            }
            return null;
        }
    }

    async function performAutoRecognition() {
        if (!autoModeEnabled || isProcessingAttendance) return;

        const result = await captureAndRecognize(true);
        
        if (result && result.status !== 'error') {
            const currentEmployee = result.employee_id;
            
            if (currentEmployee) {
                if (currentEmployee === lastRecognizedEmployee) {
                    // Same person detected
                    const currentTime = Date.now();
                    const elapsedTime = currentTime - recognitionStartTime;
                    const remainingTime = Math.ceil((RECOGNITION_THRESHOLD_MS - elapsedTime) / 1000);
                    
                    if (elapsedTime >= RECOGNITION_THRESHOLD_MS && !isProcessingAttendance) {
                        // Threshold reached - mark attendance
                        isProcessingAttendance = true;
                        updateRecognitionStatus('Processing attendance...');
                        
                        // Call the attendance marking endpoint
                        try {
                            const attendanceResult = await captureAndMarkAttendance();
                            if (attendanceResult) {
                                updateStatus(attendanceResult.message, attendanceResult.status);
                            }
                        } catch (error) {
                            console.error('Error marking attendance:', error);
                        }
                        
                        // Reset for next recognition - longer cooldown to prevent immediate re-recognition
                        setTimeout(() => {
                            lastRecognizedEmployee = null;
                            recognitionStartTime = null;
                            isProcessingAttendance = false;
                            updateRecognitionStatus('Ready for next person...');
                        }, 5000); // 5 second cooldown after marking
                    } else if (!isProcessingAttendance) {
                        updateRecognitionStatus(`Recognizing... ${remainingTime}s remaining`);
                    }
                } else {
                    // Different person detected
                    lastRecognizedEmployee = currentEmployee;
                    recognitionStartTime = Date.now();
                    updateRecognitionStatus(`Face detected. Hold position for 5 seconds...`);
                }
            } else {
                // No face detected
                if (lastRecognizedEmployee && !isProcessingAttendance) {
                    updateRecognitionStatus('Face lost. Please reposition...');
                    lastRecognizedEmployee = null;
                    recognitionStartTime = null;
                }
            }
        } else {
            // Error or no recognition
            if (lastRecognizedEmployee && !isProcessingAttendance) {
                updateRecognitionStatus('Recognition failed. Please try again...');
                lastRecognizedEmployee = null;
                recognitionStartTime = null;
            }
        }
    }

    async function captureAndMarkAttendance() {
        // This function actually marks the attendance and triggers TTS
        if (!stream || !video.srcObject || video.paused || video.ended || video.readyState < video.HAVE_CURRENT_DATA) {
            return null;
        }

        const context = snapshotCanvas.getContext('2d');
        if (snapshotCanvas.width !== video.videoWidth || snapshotCanvas.height !== video.videoHeight) {
            snapshotCanvas.width = video.videoWidth;
            snapshotCanvas.height = video.videoHeight;
        }

        if (video.style.transform === 'scaleX(-1)') {
            context.translate(snapshotCanvas.width, 0);
            context.scale(-1, 1);
            context.drawImage(video, 0, 0, snapshotCanvas.width, snapshotCanvas.height);
            context.setTransform(1, 0, 0, 1, 0, 0);
        } else {
            context.drawImage(video, 0, 0, snapshotCanvas.width, snapshotCanvas.height);
        }
        const imageDataURL = snapshotCanvas.toDataURL('image/jpeg', 0.9);

        try {
            const response = await fetch("{{ url_for('mark_attendance_route') }}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    image_data: imageDataURL,
                    auto_mode: true  // This will trigger TTS on the server
                }),
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server error: ${response.status} ${response.statusText}. ${errorText}`);
            }
            const result = await response.json();
            return result;

        } catch (error) {
            console.error('Error marking attendance:', error);
            return null;
        }
    }

    function startAutoRecognition() {
        if (autoRecognitionInterval) return;
        
        lastRecognizedEmployee = null;
        recognitionStartTime = null;
        isProcessingAttendance = false;
        
        autoRecognitionInterval = setInterval(performAutoRecognition, AUTO_CHECK_INTERVAL_MS);
        updateRecognitionStatus('Auto mode active. Scanning for faces...');
    }

    function stopAutoRecognition() {
        if (autoRecognitionInterval) {
            clearInterval(autoRecognitionInterval);
            autoRecognitionInterval = null;
        }
        lastRecognizedEmployee = null;
        recognitionStartTime = null;
        isProcessingAttendance = false;
        updateRecognitionStatus('');
    }

    // Auto Mode Toggle Handler
    autoModeToggle.addEventListener('change', function() {
        autoModeEnabled = this.checked;
        
        if (autoModeEnabled) {
            autoModeIndicator.classList.add('active');
            manualControls.style.display = 'none';
            startAutoRecognition();
            updateStatus('Auto mode enabled. System will automatically recognize faces.', 'info');
        } else {
            autoModeIndicator.classList.remove('active');
            manualControls.style.display = 'block';
            stopAutoRecognition();
            updateStatus('Switched to manual mode.', 'secondary');
        }
    });

    // Manual Attendance Button
    markAttendanceBtn.addEventListener('click', async function () {
        if (autoModeEnabled) return; // Prevent manual marking in auto mode
        
        markAttendanceBtn.disabled = true;
        updateStatus('Processing...', 'info', 1500);

        const result = await captureAndRecognize(false);
        
        if (result) {
            updateStatus(result.message, result.status);
        }
        
        markAttendanceBtn.disabled = false;
    });

    stopCameraBtn.addEventListener('click', stopCamera);

    // Initialize
    updateISTClock();
    clockIntervalId = setInterval(updateISTClock, 1000);
    startCamera();

    // Handle Page Visibility
    document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
            if (clockIntervalId) clearInterval(clockIntervalId);
            stopAutoRecognition();
        } else if (document.visibilityState === "visible") {
            if (!clockIntervalId) {
                 updateISTClock();
                 clockIntervalId = setInterval(updateISTClock, 1000);
            }
            if (autoModeEnabled) {
                startAutoRecognition();
            }
        }
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        stopCamera();
        if (clockIntervalId) clearInterval(clockIntervalId);
    });
});
</script>
{% endblock %}